<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Introduction</title>
</head>

<body>

<p><img border="0" src="ui4.png" width="748" height="497"></p>
<h2>Introduction</h2>
<p>We have these brain teaser puzzles at work:</p>
<p><img border="0" src="pegboard.jpg" width="400" height="286"></p>
<p>We've probably all played them -- the idea being you start with one empty 
hole, the rest are filled with pegs, and each move consists of hopping a peg to 
an empty location, thus removing the peg you just hopped.&nbsp; The goal is to 
remain with just one peg left.</p>
<p>For a roomful of programmers, no one (including me!) so far has been able to solve the puzzle.&nbsp; Watching one of my 
coworkers futility go through various failed iterations, I had the obvious 
thought -- write a program to find solutions to the puzzle!&nbsp; The second 
obvious thought was, someone must have done this!&nbsp; Well, turns out, not 
really.&nbsp; </p>
<ul>
	<li>There is a
	<a href="https://www.codeproject.com/Articles/272466/Triangle-Peg-Solitaire">
	Java article</a> here on CodeProject.</li>
	<li>There's a <a href="https://gist.github.com/losvedir/661564">C program 
	here</a> that solves the puzzle.</li>
	<li>A nice C++ recursive algorithm
	<a href="https://stackoverflow.com/questions/6393391/timeout-on-a-php-peg-puzzle-solver">
	here</a>.</li>
	<li>And a PHP solver
	<a href="https://bitbucket.org/rcourtie/peg-solitaire/src/tip/peg-solitaire.php?fileviewer=file-view-default">
	here</a>.</li>
</ul>
<p>OK, so while there are several solutions, I actually didn't find one in C#, 
and even if I had, there is a certain pleasure in writing something like this 
oneself, even if it's been done before.&nbsp; And of course, one can challenge 
oneself to write the code as elegantly and efficiently as possible, etc.&nbsp; 
And more to the point, none of the algorithms presented:</p>
<ul>
	<li>had a snazzy UI so you could watch the algorithm processing.</li>
	<li>implemented iteration and recursion alternatives.</li>
</ul>
<p>Ah, opportunity!</p>
<p><img border="0" src="wayoverboard.jpg" width="120" height="119">And as is apt 
to occur, I went way overboard.</p>
<p>So the solution I present here:</p>
<ul>
	<li>Has a funky extension method which may or may not make the code 
	more readable.</li>
	<li>Uses a lot of Linq.</li>
	<li>Embeds <a href="https://www.codeproject.com/Articles/1136050/FlowSharp">
	FlowSharp</a> so you can watch the algorithm go through the process of 
	finding a solution (why re-invent the wheel?)</li>
	<li>Let's you single step through the solution and watch each step so you 
	can memorize the solution and impress your friends!</li>
	<li>As with the actual cheap game, there are 3 different colored pegs -- 
	yellow, blue, and red -- which the UI implements, randomly assigned when you 
	start the demo.</li>
	<li><b>Implements three different algorithms</b> so you can peruse the pros and 
	cons of each:<ul>
	<li>Iterative -- the search stack is handled as handled as an actual <code>Stack</code> 
	object.</li>
	<li>Recursive using <code>yield</code> -- the search stack is an artifact of recursion.</li>
	<li>Recursive with callback -- again the search stack is an artifact of 
	recursion.</li>
</ul>
	</li>
	<li>Was fun to write!</li>
</ul>
<h2>The Game Board</h2>
<p>A lot of the work is done up front by setting up collections that have 
pre-determined all the possible &quot;hops&quot; from one &quot;cell&quot; to another.&nbsp; The 
algorithm only needs to determine which of these &quot;hops&quot; is legal for the current 
board configuration.</p>
<h3>Extension Methods</h3>
<p>I decided to borrow from Ruby to create an extension method that iterates on 
an integer with an optional starting offset:</p>
<pre>public static void ForEach(this int i, Action&lt;int&gt; action, int startIdx = 0)
{
  for (int n = startIdx; n &lt; i + startIdx; n++) action(n);
}</pre>
<p>You'll see that used next.</p>
<p>I also use this extension method to convert a color to an HTML color of the 
form #RRGGBB:</p>
<pre>public static string ToHtmlColor(this Color c, char prefix = '#')
{
  return prefix + c.R.ToString(&quot;X2&quot;) + c.G.ToString(&quot;X2&quot;) + c.B.ToString(&quot;X2&quot;);
}</pre>
<h3>Data Structures</h3>
<p>The basic data structures are the <code>Row</code> and <code>Cell</code>.</p>
<h4>Row</h4>
<p>The board consists of an array of rows:</p>
<pre>protected Row[] rows;</pre>
<p>which consist of an array of cells:</p>
<pre>public class Row
{
  public Cell[] Cells { get; protected set; }

  public Row(int numCells)
  {
    Cells = new Cell[numCells];
    numCells.ForEach(n =&gt; Cells[n] = new Cell());
  }
}</pre>
<p>Initialization of the game board embeds the rule that the number of cells is 
equal to the 1-base index of the row number:</p>
<pre>protected void InitializeRowsAndColumns(int numRows)
{
  rows = new Row[numRows];
  numRows.ForEach(n =&gt; rows[n] = new Row(n + 1));
}</pre>
<h4>Cell</h4>
<p>A cell consists of its state (empty or has a peg) and an initial random seed 
of the peg color:</p>
<pre>public class Cell
{
  public Color Color { get; set; }

  // More semantically friendly:
  public bool HasPeg { get { return state; } set { state = value; } }
  public bool IsEmpty { get { return !state; } }

  protected bool state;

  private static Random rnd = new Random(DateTime.Now.Second);
  private static Color[] colors = { Color.Red, Color.Blue, Color.Yellow };

  public Cell()
  {
    Color = colors[rnd.Next(colors.Length)];
  }
}</pre>
<p>Note the <code>HasPeg</code> and <code>IsEmpty</code> properties, which improve the code readability 
in other methods, 
rather than exposing <code>state</code>.&nbsp; Also note that the cell contains 
a static Random instance and the collection of possible peg colors.</p>
<h4>The Flat View</h4>
<p>Except for initialization, the algorithm to solve the puzzle works with 
integer indices of the cells, rather than their row/column location.&nbsp; Among 
other things, this simplifies how possible hops are determined, as well as 
updating the UI.&nbsp; It's a lot easier (and more performant) if you don't 
constantly have to look up a cell state by it's row/column location.&nbsp; So 
internally, the board maintains a flat view of all the cells:</p>
<pre>protected List&lt;Cell&gt; flatView;</pre>
<p>Initialization of the flat view is straightforward:</p>
<pre>protected void InitializeFlatView()
{
  flatView = new List&lt;Cell&gt;();
  rows.ForEach(r =&gt; r.Cells.ForEach(c =&gt; flatView.Add(c)));
}</pre>
<p>This illustrates an important point: there are often two or more ways to 
model a structure, and depending on what you're doing, it's easier to work with 
one model vs. another.&nbsp; We see this next, where initializing all the hops 
is more readable if we work with the row/column model.</p>
<h3>Working with Rows and Columns</h3>
<p>A cell location (as a row/column) mapped to its index in the flat view 
(above) is useful for initialization.&nbsp; The mapping is done with a 
<code>dictionary</code>:</p>
<pre>protected Dictionary&lt;Location, int&gt; cellToIndexMap;</pre>
<p>but when we use a structure as the dictionary key, a simple way (without 
writing comparison operators) is to represent the structure as a C# <code>struct</code> 
rather than a <code>class</code>:</p>
<pre>/// &lt;summary&gt;
/// Struct, so it can be used as a value field for indexing a dictionary.
/// &lt;/summary&gt;
public struct Location
{
  public int Row { get; set; }
  public int Column { get; set; }

  public Location(int row, int column)
  {
    Row = row;
    Column = column;
  }
}</pre>
<p>Why?&nbsp; By using a struct, the key is compared <i>by value</i> as opposed 
to <i>by reference.</i></p>
<p>We then initialize map:</p>
<pre>protected void InitializeCellToIndexMap()
{
  cellToIndexMap = new Dictionary&lt;Location, int&gt;();
  int n = 0;
  rows.ForEachWithIndex((r, ridx) =&gt; r.Cells.ForEachWithIndex((c, cidx) =&gt; cellToIndexMap[new Location(ridx, cidx)] = n++));
}</pre>
<p>This is used next.</p>
<h3>Determining All Possible Hops</h3>
<p>The workhorse of the algorithm depends on initializing a structure that 
contains all possible hops (validity of the hop is checked later.)&nbsp; This 
takes advantage of the cell location to index map that we created earlier.&nbsp; 
Here we introduce the <code>Hop</code> class:</p>
<pre>public class Hop
{
  public int FromCellIndex { get; protected set; }
  public int ToCellIndex { get; protected set; }
  public int HoppedCellIndex { get; protected set; }

  public Color FromCellColor { get; set; }
  public Color HoppedCellColor { get; set; }
  public Color ToCellColor { get; set; }

  public Hop(int from, int to, int hopped)
  {
    FromCellIndex = from;
    ToCellIndex = to;
    HoppedCellIndex = hopped;
  }

  /// &lt;summary&gt;
  /// We clone the Hop so that the color state is preserved for this *specific* hop.
  /// Otherwise, the Hop instance might be re-used in a later iteration and the previous
  /// Hop instance's color state will be overwritten by the new hop.
  /// &lt;/summary&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  public Hop Clone()
  {
    Hop hop = new Hop(FromCellIndex, ToCellIndex, HoppedCellIndex);

    return hop;
  }

  public override string ToString()
  {
    string ret = &quot;Finished!&quot;;

    if (FromCellIndex != -1)
    {
      ret = FromCellIndex.ToString() + &quot; to &quot; + ToCellIndex.ToString() + &quot; over &quot; + HoppedCellIndex.ToString();
    }

    return ret;
  }
}</pre>
<p>Notice a few things about the <code>Hop</code> class:</p>
<ul>
	<li>A hop knows its from, to, and cell hopped over indices.</li>
<li>A hop preserves the state of the peg colors involved in the hop.&nbsp; We'll 
see later that these colors are assigned when a hop is made based on the current 
game board state.</li>
	<li>Notice the <code>Clone</code> method.&nbsp; In the board's model, there 
	is only one instance of each possible hop.&nbsp; However, because a hop 
	preserves color state information, we need a cloned instance for the reason 
	that the comment states.</li>
	<li>The <code>ToString()</code> method gives us an easy way to display the solution in a 
	<code>ListBox</code> of hops.</li>
</ul>
<p><img border="0" src="trivia.png" width="120" height="103">The issue of 
preserving color was actually the hardest bug to solve.&nbsp; It took me quite a 
while to realize that the Hop instance was being re-used for multiple 
iterations, thus overwriting the colors of a previous iteration!</p>
<p>Initializing all the possible hops populates the <code>List&lt;Hop&gt; allHops</code> structure:</p>
<pre>protected void InitializeAllHops()
{
  // The idea here is to allow for diagonal down-left and down-right hops and left-to-right hops.
  allHops = new List&lt;Hop&gt;();
  rows.ForEachWithIndex((r, ridx) =&gt;
  {
    r.Cells.ForEachWithIndex((c, cidx) =&gt;
    {
      AddHorizontalHop(r, ridx, cidx);

      // Check for valid diagonal hop, which is any hop downward where the target cell exists.
      if (rows.Length &gt; ridx + 2)
      {
        AddDiagonalLeftHop(r, ridx, cidx);
        AddDiagonalRightHop(r, ridx, cidx);
      }
    });
  });
}

protected void AddHorizontalHop(Row r, int ridx, int cidx)
{
  if (r.Cells.Length &gt; cidx + 2)
  {
    int fromIdx = GetIndex(ridx, cidx);
    int toIdx = GetIndex(ridx, cidx + 2);
    int hopIdx = GetIndex(ridx, cidx + 1);
    AddHop(fromIdx, toIdx, hopIdx);
  }
}

protected void AddDiagonalLeftHop(Row r, int ridx, int cidx)
{
  // Note that the column index stay constant.
  int fromIdx = GetIndex(ridx, cidx);
  int toIdx = GetIndex(ridx + 2, cidx);
  int hopIdx = GetIndex(ridx + 1, cidx);
  AddHop(fromIdx, toIdx, hopIdx);
}

protected void AddDiagonalRightHop(Row r, int ridx, int cidx)
{
  // Note how the col index increments.
  // We know that the column to the right always exists because it's a triangle!
  int fromIdx = GetIndex(ridx, cidx);
  int toIdx = GetIndex(ridx + 2, cidx + 2);
  int hopIdx = GetIndex(ridx + 1, cidx + 1);
  AddHop(fromIdx, toIdx, hopIdx);
}</pre>
<p>And because hops can be performed &quot;forward&quot; and &quot;backwards&quot;:</p>
<pre>/// &lt;summary&gt;
/// Add both &quot;forward&quot; and &quot;backward&quot; hop.
/// &lt;/summary&gt;
protected void AddHop(int fromIdx, int toIdx, int hopIdx)
{
  allHops.Add(new Hop(fromIdx, toIdx, hopIdx));
  allHops.Add(new Hop(toIdx, fromIdx, hopIdx));
}</pre>
<p>The method GetIndex asserts that the index can be obtained for the 
row/column by verifying the existence of the map key:</p>
<pre>public int GetIndex(int row, int col)
{
  int idx;
  bool found = cellToIndexMap.TryGetValue(new Location(row, col), out idx);
  Assert.That(found, string.Format(&quot;Location at {0}, {1} does not exist.&quot;, row, col));

  return idx;
}</pre>
<h3>Getting Allowed Hops</h3>
<p>This is a fun Linq expression that joins the flat view index with the 
fromCellIndex of all possible hops and filtering the return for only &quot;from&quot; 
cells where the &quot;to&quot; cell is empty and the cell being hopped over has a peg:</p>
<pre>public List&lt;Hop&gt; GetAllowedHops()
{
  // For each possible cell...
  // where the cell has a peg...
  // we have the index of the cell...
  // and join with hops having a &quot;from&quot; index of the cells with pegs...
  // and the hop has a &quot;to&quot; that is empty and a hopped cell that has a peg.
  // and clone the hops, because we need to preserve color state information for the specific hop,
  // as the exact hop may occur again in a later iteration.

  var allowedHops = Enumerable.Range(0, flatView.Count()).
    Where(n =&gt; flatView[n].HasPeg).
    Join(allHops, pegIdx =&gt; pegIdx, hop =&gt; hop.FromCellIndex, (pegIdx, hop) =&gt; hop).
    Where(hop =&gt; flatView[hop.ToCellIndex].IsEmpty &amp;&amp; flatView[hop.HoppedCellIndex].HasPeg).
    Select(hop =&gt; hop.Clone()).ToList();

  return allowedHops;
}</pre>
<h3>Doing and Undoing Hops</h3>
<p>Lastly, the Board class provides the methods for performing a hop, or undoing 
a hop.&nbsp; Undoing a hop is necessary when unwinding the collection of hops 
for a failed solution, which we'll look at in the algorithm section.</p>
<pre>	/// &lt;summary&gt;
/// Move a peg to the empty &quot;to&quot; cell, removing the peg hopped over.
/// &lt;/summary&gt;
/// &lt;param name=&quot;hop&quot;&gt;&lt;/param&gt;
public void HopPeg(Hop hop)
{
  Assert.That(flatView[hop.FromCellIndex].HasPeg, &quot;Expected from cell to be have a peg.&quot;);
  Assert.That(flatView[hop.ToCellIndex].IsEmpty, &quot;Expected to cell to be empty.&quot;);
  Assert.That(flatView[hop.HoppedCellIndex].HasPeg, &quot;Expected to cell have a peg.&quot;);

  // Perform hop. From cell is emptied, cell being hopped is emptied, to cell is occupied.
  flatView[hop.FromCellIndex].HasPeg = false;
  flatView[hop.HoppedCellIndex].HasPeg = false;
  flatView[hop.ToCellIndex].HasPeg = true;

  // Save color state of from/hopped/to cells
  hop.FromCellColor = flatView[hop.FromCellIndex].Color;
  hop.HoppedCellColor = flatView[hop.HoppedCellIndex].Color;
  hop.ToCellColor = flatView[hop.ToCellIndex].Color;

  // Update color of To with color of From.
  flatView[hop.ToCellIndex].Color = hop.FromCellColor;

  DoHop.Fire(this, new CellChangeEventArgs() { Hop = hop, State = true });
}

/// &lt;summary&gt;
/// The reverse process, restores pegs in the to cell, hopped cell, and removes the peg in the from cell.
/// &lt;/summary&gt;
public void UndoHopPeg(Hop hop)
{
  Assert.That(flatView[hop.FromCellIndex].IsEmpty, &quot;Expected from cell to be empty.&quot;);
  Assert.That(flatView[hop.ToCellIndex].HasPeg, &quot;Expected to cell to have a peg.&quot;);
  Assert.That(flatView[hop.HoppedCellIndex].IsEmpty, &quot;Expected to cell to be empty.&quot;);

  flatView[hop.FromCellIndex].HasPeg = true;
  flatView[hop.HoppedCellIndex].HasPeg = true;
  flatView[hop.ToCellIndex].HasPeg = false;

  // Restore colors
  flatView[hop.FromCellIndex].Color = hop.FromCellColor;
  flatView[hop.HoppedCellIndex].Color = hop.HoppedCellColor;
  flatView[hop.ToCellIndex].Color = hop.ToCellColor;

  UndoHop.Fire(this, new CellChangeEventArgs() { Hop = hop, State = false });
}</pre>
<p>Notice that we do some more assertions here, in case the algorithm asked the 
board to perform an illegal operation.&nbsp; Also notice that we're managing the 
peg color here, preserving the original color of the peg being hopped over.&nbsp; 
Lastly, a couple events fire that are wired up by the UI:</p>
<pre>public event EventHandler&lt;CellChangeEventArgs&gt; DoHop;
public event EventHandler&lt;CellChangeEventArgs&gt; UndoHop;</pre>
<p>We'll look at how the UI uses these events later on.</p>
<h2>The Algorithm</h2>
<p>As other implementations have stated, the algorithm is a Depth First Search (<a href="https://en.wikipedia.org/wiki/Depth-first_search">DSF</a>) 
process.&nbsp; From the link:</p>
<p><i>&quot;Depth-first search (DFS) is an algorithm for traversing or searching tree 
or graph data structures. One starts at the root (selecting some arbitrary node 
as the root in the case of a graph) and explores as far as possible along each 
branch before backtracking.&quot;</i></p>
<p>In our case, the &quot;root&quot; is all possible hops with just one empty cell.&nbsp; 
After choosing a hop, all new allowable hops are determined, and the first one 
is chosen.&nbsp; This process repeats until the puzzle is solved or no further 
hops can be made.&nbsp; If no further hops can be made, the algorithm unwinds 
one level and chooses the next hop of allowable hops.&nbsp; If there are no more 
allowable hops, the algorithm unwinds again.&nbsp; This process is repeated 
until it gets back to the root's allowable hops.&nbsp; If no solution has been 
found at that point, the algorithm exits with &quot;no solution found.&quot;&nbsp; (Hint 
-- all the possible starting positions are solvable.)</p>
<h3>Data Structures</h3>
<p>The following data structures are used.</p>
<h4>HopOptions</h4>
<p>This is a class that manages all allowable hops for a particular level (board 
state) and sequencing through that list:</p>
<pre>public class HopOptions
{
  protected List&lt;Hop&gt; hops;
  protected int hopIdx;

  public Hop CurrrentHop { get { return hops[hopIdx]; } }

  public HopOptions(List&lt;Hop&gt; hops)
  {
    this.hops = hops;
    hopIdx = 0;
  }

  public bool NextOptionIndex()
  {
    return ++hopIdx &lt; hops.Count;
  }
}</pre>
<p>Note that when all the hop options have been exercised, <code>NextOptionIndex</code> 
returns false, indicating that the stack needs to be unwound.</p>
<h4>HopStack and UndoStack</h4>
<p>The hop stack:</p>
<pre>public Stack&lt;HopOptions&gt; HopStack { get; protected set; }</pre>
<p>maintains the current state of the search algorithm, as a stack.&nbsp; When a 
hop is made, the hop options for the new board state are pushed onto this stack.&nbsp; 
When all the possible hops at this level have been exercised, the stack is 
popped.</p>
<p>The undo stack:</p>
<pre>public Stack&lt;Hop&gt; UndoStack { get; protected set; }</pre>
<p>is a different representation of the <code>HopStack</code>.&nbsp; The <code>UndoStack</code> tracks the 
current hop that has been taken.&nbsp; The undo stack could be determined from 
the <code>HopStack</code> and its current index, so this model is a convenience -- it 
represents the current path through the <code>HopStack</code>.</p>
<h3>To Iterate or to Recurse?</h3>
<p>You might surmise at this point, since I'm utilizing actual <code>Stack</code> 
collections, that the algorithm is iterative rather than recursive.&nbsp; A 
recursive algorithm would utilize the actual program stack for maintaining 
state.&nbsp; The reason for this is so that we can easily implement a &quot;single 
step&quot; behavior.&nbsp; A recursive algorithm is not amenable to single stepping 
through each permutation because it would have to exit all recursion levels and 
then re-enter them magically to continue with the next step.</p>
<h4>What about the Yield operator?</h4>
<p>This is definitely a possibility.&nbsp; For example, this code:</p>
<pre>static void Main(string[] args)
{
  YieldTest(0).ForEach(n =&gt; Console.WriteLine(n));
}

static IEnumerable&lt;int&gt; YieldTest(int n)
{
  yield return n;

  if (++n &lt; 5)
  {
    foreach (int q in YieldTest(n))
    {
      yield return q;
    }
  }
}</pre>
<p>prints &quot;0 1 2 3 4&quot; and demonstrates how each iteration can be &quot;stepped&quot; by 
iterating through the enumerator.</p>
<h4>What about a Step-And-Continue callback?</h4>
<p>A callback for each recursive call would allow the handler to suspend and 
wait for user input stepper, and unlike the <code>yield</code> operator, has the advantage of 
being able to return a &quot;cancel&quot; flag.</p>
<p>Because this is one of those &quot;let's have fun&quot; articles, I'll show you how 
iteration, recursion with yield, and recursion with a step-and-continue callback 
works.</p>
<h3>Iterative Algorithm</h3>
<p>The iterative algorithm is actually the easiest to implement when dealing 
with the single step option.&nbsp; It implements the <code>Run</code> method.</p>
<h4>Run</h4>
<pre>public override void Run()
{
  while (board.RemainingPegs &gt; 1 &amp;&amp; Step())
  {
    Hop hop = PushHop();
  }

  Solved = board.RemainingPegs == 1;
}</pre>
<p>which does little more than single step through each iteration, pushing state 
information as it goes along.</p>
<h4>PushHop</h4>
<p>Because we are maintaining our own stack (as opposed to a recursive algorithm 
that maintains the stack as local variables on the program stack), we need to 
push our current state onto our two stack model representations (the <code>HopStack</code> 
and the <code>UndoStack</code>):</p>
<pre>public override Hop PushHop()
{
  Hop hop = HopStack.Peek().CurrrentHop;
  board.HopPeg(hop);
  UndoStack.Push(hop);

  return hop;
}</pre>
<h4>Step</h4>
<p>The <code>Step</code> method is where the iteration is implemented, in the 
sense that it attempts each possible hop, and when no further hops are possible, 
the stack is unwound.</p>
<pre>public override bool Step()
{
  bool next = true;
  List&lt;Hop&gt; allowedHops = board.GetAllowedHops();

  if (allowedHops.Count == 0)
  {
    // No solution. Unwind.
    next = Unwind();
  }
  else
  {
    HopOptions hopOptions = new HopOptions(allowedHops);
    HopStack.Push(hopOptions);
  }

  return next;
}</pre>
<h4>Unwind</h4>
<p>When the algorithm cannot move forward anymore, the stacks are unwound until 
there are more forward iterations possible:</p>
<pre>protected bool Unwind()
{
  bool more = false;

  while (!more &amp;&amp; HopStack.Count &gt; 0)
  {
    Hop undoHop = UndoStack.Pop();
    board.UndoHopPeg(undoHop);
    more = HopStack.Peek().NextOptionIndex();

    if (!more)
    {
      HopStack.Pop();
    }
  }

  return more;
}</pre>
<h3>The Recursive Yield Algorithm</h3>
<p>The recursive yield algorithm is much simpler!</p>
<h4>Run</h4>
<pre>public override void Run()
{
  foreach(Hop hop in Step(new HopOptions(board.GetAllowedHops())))
  {
    board.HopPeg(hop);
    Solved = board.RemainingPegs == 1;

    if (Solved)
    {
      // It's amazing how we can break out of a recursive yield!
      // But that's actually because the yield operator flattens 
      // the recursion into iteration!
      break;
    }
  }
}</pre>
<p>The neat thing here is that the stepper method <code>Step</code> returns an <code>IEnumerable&lt;Hop&gt;</code>, 
so all the <code>Run</code> method has to do is iterate through the enumeration until a 
solution is found.&nbsp; Note the comment.</p>
<h4>Step</h4>
<pre>protected IEnumerable&lt;Hop&gt; Step(HopOptions hopOptions)
{
  while (hopOptions.OptionAvailable)
  {
    Hop hop = hopOptions.CurrrentHop;
    UndoStack.Push(hop);
    yield return hop;

    List&lt;Hop&gt; allowedHops = board.GetAllowedHops();

    foreach (Hop nextHop in Step(new HopOptions(allowedHops)))
    {
      yield return nextHop;
    }

    UndoStack.Pop();
    board.UndoHopPeg(hop);
    hopOptions.NextOptionIndex();
  }
}</pre>
<p>The stepper, because it's implemented as a recursive algorithm, doesn't need 
to maintain a separate stack -- the recursion passing in the <code>HopOptions 
hopOptions</code> lets the program stack implement what, in the iterative algorithm, 
was handled by the <code>Stack&lt;HopOptions&gt; HopStack</code>.&nbsp; Note that 
we are still implementing the <code>UndoStack</code> push/pop, as this is a separate model 
for the convenience of the UI.</p>
<p>As the comment earlier mentioned, the neat thing about the <code>yield</code> operator is 
that it flattens the recursion -- the code looks like recursion, but it actually 
ends up implementing iteration.&nbsp; Read more:</p>
<ul>
	<li>
	<a href="https://startbigthinksmall.wordpress.com/2008/06/09/behind-the-scenes-of-the-c-yield-keyword/">Lars Corneliussen - Behind the Scenes of the C# Yield Keyword</a></li>
	<li>
	<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield">yield (C# Reference)</a> In particular, note this statement: 
	<i>When you use the 
yield keyword in a statement, you indicate that the method, operator, or get 
accessor in which it appears is <b>an iterator</b>.</i> (my bolding.)</li>
</ul>
<h3>The Recursive Step and Continue Algorithm</h3>
<p>This algorithm replaces the <code>yield</code> with a callback for updating the game board 
at every iteration:</p>
<pre>protected bool Step(HopOptions hopOptions, Func&lt;Hop, bool&gt; callback)
{
  while (hopOptions.OptionAvailable)
  {
    Hop hop = hopOptions.CurrrentHop;
    UndoStack.Push(hop);

    if (callback(hop))
    {
      return false;
    }

    List&lt;Hop&gt; allowedHops = board.GetAllowedHops();
    bool cont = Step(new HopOptions(allowedHops), Callback);
    
    if (!cont)
    {
      return false;
    }

    UndoStack.Pop();
    board.UndoHopPeg(hop);
    hopOptions.NextOptionIndex();
  }

  return true;
}</pre>
<p>The inner <code>for</code> loop that the recursive yield algorithm used is also gone as 
it's now unnecessary.&nbsp; Note however that we have to provide a mechanism for 
unraveling the recursion when the algorithm is solved.&nbsp; (This is slight 
confusing, because the callback returns true if the algorithm is solved, but the 
stepper returns false if it's supposed to abort.</p>
<h4>Run</h4>
<p>Running the solver is a simple matter of:</p>
<pre>public override void Run()
{
  Step(new HopOptions(board.GetAllowedHops()), Callback);
}</pre>
<p>The callback is the critical piece, as it returns true if the puzzle has been 
solved:</p>
<pre>/// &lt;summary&gt;
/// Return true if a solution has been found, which cancels the recursion.
/// &lt;/summary&gt;
protected bool Callback(Hop hop)
{
  ++Iterations;
  board.HopPeg(hop);
  Solved = board.RemainingPegs == 1;

  return Solved;
}</pre>
<p><img border="0" src="sneaky.png" width="120" height="95">&nbsp; Note that at 
this point, I added an iteration counter to all the algorithms.</p>
<h4>The Complexity of Single Stepping</h4>
<p>So far, the iterative and recursive yield approach have both had the 
advantage that single stepping easily works on the application thread -- both 
approaches &quot;return control&quot; to the UI, which (as we will see later) when single 
stepping, lets the single step button click continue the iteration.&nbsp; This 
is not the case with a non-yielding, or &quot;step and continue&quot;, as I call it, 
recursion.&nbsp; In order to suspend the recursive algorithm, we have to &quot;gate&quot; 
the continuation so that the algorithm suspends operation until the user clicks on the single step button.&nbsp; A cheap and dirty approach is to call <code>Application.DoEvents()</code> 
and spin until a flag is set indicating that the algorithm can continue.&nbsp; 
This is what I consider a beginner's approach to the problem.&nbsp; A better 
approach is to use a semaphore to gate the continuation, and to execute the 
algorithm on a separate thread.&nbsp; This is the approach that I took.</p>
<p>First, we have the semaphore and its initialization:</p>
<pre>/// &lt;summary&gt;
/// Used for single stepping.
/// &lt;/summary&gt;
protected Semaphore hopSemaphore;

public RecursiveStepAndContinueAlgorithm(Board board) : base(board)
{
  hopSemaphore = new Semaphore(0, 1);
}</pre>
<p>To initialize the stepper, we start a task and wait for the semaphore to be 
released:</p>
<pre>public override void StartStepper()
{
  Task.Factory.StartNew(() =&gt;
  {
    hopSemaphore.WaitOne();
    Step(new HopOptions(board.GetAllowedHops()), SingleStepCallback);
  });
}</pre>
<p>Note that the callback that the recursive algorithm uses for single stepping 
is different than the callback for simply running the algorithm to conclusion.</p>
<p>Our stepper then releases the semaphore:</p>
<pre>public override bool Step()
{
  ++Iterations;
  bool isSolved = !(board.RemainingPegs == 1);
  hopSemaphore.Release();

  return isSolved;
}</pre>
<p>The callback performs the hop, sets the solved flag, and waits until the 
semaphore is released again before returning to the recursion algorithm:</p>
<pre>protected bool SingleStepCallback(Hop hop)
{
  board.HopPeg(hop);
  Solved = board.RemainingPegs == 1;
  hopSemaphore.WaitOne();

  return Solved;
}</pre>
<h4>Why No Marshalling Onto The Main Thread?</h4>
<p>An astute question is, why isn't this call:</p>
<pre>board.HopPeg(hop);</pre>
<p>marshaled onto the main thread?&nbsp; The reason is that the UI code that 
handles the <code>DoHop</code> and <code>UndoHop</code> events only updates the text boxes and list 
boxes when the algorithm is <i>running</i>, not 
when the algorithm is <i>single stepping.</i>&nbsp; The stepper UI code updates 
these controls separately on the main application thread.&nbsp; A further explanation of 
this logic will be revealed when we discuss the UI next.</p>
<h2>The UI</h2>
<p>Next, we'll look at the UI.</p>
<h3>The Visual Game Board</h3>
<p><img border="0" src="ui2.png" width="366" height="342"></p>
<p>The game board is rendered by embedding the FlowSharp canvas, which is a 
four 
step process:</p>
<h4>Step 1: Initializing the FlowSharp modules with the bootstrap loader</h4>
<pre>Bootstrap(&quot;modules.xml&quot;);</pre>
<p>The minimum set of modules needed is described in the XML file:</p>
<pre>&lt;Modules&gt;
  &lt;Module AssemblyName='Clifton.SemanticProcessorService.dll'/&gt;
  &lt;Module AssemblyName='FlowSharpService.dll'/&gt;
  &lt;Module AssemblyName='FlowSharpCanvasService.dll'/&gt;
  &lt;Module AssemblyName='FlowSharpMouseControllerService.dll'/&gt;
  &lt;Module AssemblyName='FlowSharpToolboxService.dll'/&gt;
  &lt;Module AssemblyName='FlowSharpRestService.dll'/&gt;
  &lt;Module AssemblyName='FlowSharpWebSocketService.dll'/&gt;
&lt;/Modules&gt;</pre>
<p>Read more about the bootstrap process and FlowSharp's SOA:</p>
<ul>
	<li>
	<a href="https://www.codeproject.com/Articles/1120518/The-Clifton-Method-Part-III">
	The Clifton Method Part III - Bootstrapping</a></li>
<li><a href="https://www.codeproject.com/Articles/1136050/soa#123116">
FlowSharp's Service Oriented Architecture</a></li>
</ul>
<h4>Step 2: Initializing FlowSharp</h4>
<p>This sets up the canvas:</p>
<pre>protected void InitializeFlowSharp()
{
  var canvasService = Program.ServiceManager.Get&lt;IFlowSharpCanvasService&gt;();
  canvasService.CreateCanvas(pnlFlowSharp);
  canvasService.ActiveController.Canvas.EndInit();
  canvasService.ActiveController.Canvas.Invalidate();

  // Initialize Toolbox so we can drop shapes
  var toolboxService = Program.ServiceManager.Get&lt;IFlowSharpToolboxService&gt;();

  // We don't display the toolbox, but we need a container.
  Panel pnlToolbox = new Panel();
  pnlToolbox.Visible = false;
  Controls.Add(pnlToolbox);

  toolboxService.CreateToolbox(pnlToolbox);
  toolboxService.InitializeToolbox();

  var mouseController = Program.ServiceManager.Get&lt;IFlowSharpMouseControllerService&gt;();
  mouseController.Initialize(canvasService.ActiveController);
}</pre>
<h4>Step 3: Drawing the Game Board</h4>
<pre>protected void DrawBoard()
{
  int cx = (pnlFlowSharp.Width - 50)/2;
  int y = 50;
  int n = 0;

  Rectangle trect = new Rectangle(cx - NUM_ROWS * 50 + 65, y - 15, NUM_ROWS * 50 + 100, y + NUM_ROWS * 50 + 25);
  WebSocketHelpers.DropShape(&quot;UpTriangle&quot;, &quot;t&quot;, trect, Color.FromArgb(240, 230, 140));

  NUM_ROWS.ForEach(row =&gt;
  {
    row.ForEach(cell =&gt;
    {
      string name = &quot;c&quot; + n;
      Rectangle rect = new Rectangle(cx - 25 * row + 50 * cell, y + row * 50, 30, 30);
      WebSocketHelpers.DropShape(&quot;Ellipse&quot;, name, rect, Color.White);
      WebSocketHelpers.UpdateProperty(name, &quot;Text&quot;, n.ToString());
      ++n;
    });
  }, 1);
}</pre>
<p>Notice the funky integer ForEach extension method!&nbsp; Also notice that 
communication between the application and FlowSharp is done over a websocket 
channel.&nbsp; Why?&nbsp; Because typically FlowSharp is running as a completely 
separate application, rather than an embedded application, and I never 
implemented the interface methods for drawing shapes and setting shape 
properties.&nbsp; However, this does mean that when you run the demo for the 
first time, you'll probably see this:</p>
<p><img border="0" src="allowAccess.png" width="527" height="381"></p>
<p><img border="0" src="trustme.jpg" width="120" height="103">So just go ahead 
and click on Allow access.&nbsp; There isn't anything else nasty going on.</p>
<p>(ok, that's bizarre.&nbsp; The above image is Copyright 2004 by Melissa <i>
Clifton</i>.&nbsp; No relation that I know of!&nbsp; Also, explicit permission 
to use that image has been given.&nbsp; Visit
<a href="http://www.melissaevans.com/">her website</a>!)</p>
<h4>Step 4: Drawing the Pegs</h4>
<p>Lastly, we draw the pegs:</p>
<pre>protected void ShowPegs()
{
  board.NumCells.ForEach(n =&gt; WebSocketHelpers.UpdateProperty(&quot;c&quot; + n, &quot;FillColor&quot;, board.GetPegColor(n).Name));
  WebSocketHelpers.UpdateProperty(&quot;c&quot; + startPosition, &quot;FillColor&quot;, &quot;White&quot;);
}</pre>
<h3>Handling DoHop and UndoHop Events</h3>
<p><img border="0" src="ui1.png" width="268" height="322"></p>
<p>The game board fires these events, which the UI hooks:</p>
<pre>board.DoHop += OnHop;
board.UndoHop += OnUndoHop;</pre>
<h4>OnHop</h4>
<p>When a hop is performed, the canvas is updated to reflect the change:</p>
<pre>protected void OnHop(object sender, CellChangeEventArgs e)
{
  if (ckShowUi.Checked)
  {
    UpdateUI(
      e.Hop.FromCellIndex, e.Hop.HoppedCellIndex, e.Hop.ToCellIndex,
      Color.White, Color.White, board.GetPegColor(e.Hop.ToCellIndex));
  }
}</pre>
<p>The checkbox being checked (no pun intended) is used to prevent the UI from 
updating.&nbsp; Certain starting positions (peg #2, 11, and 13) take a LOT of 
iterations (~32,000, ~24,000, ~24,000 respectively).&nbsp; You can sit around 
for several minutes (or longer depending on the delay you've set) waiting for 
the solution watching the circles blink, or you can uncheck the &quot;UI&quot; checkbox 
and the solution will be presented pretty much instantly.</p>
<p>Notice that when a hop is performed, the &quot;from cell&quot; and &quot;hopped cell&quot; are 
turned white, and the &quot;to cell&quot; gets the peg color of the new &quot;to cell&quot; peg 
color (that was sort of redundant to say it that way.)</p>
<h4>OnUndoHop</h4>
<p>Undoing a hop is the opposite:</p>
<pre>protected void OnUndoHop(object sender, CellChangeEventArgs e)
{
  if (ckShowUi.Checked)
  {
    UpdateUI(
      e.Hop.FromCellIndex, e.Hop.HoppedCellIndex, e.Hop.ToCellIndex,
      board.GetPegColor(e.Hop.FromCellIndex), board.GetPegColor(e.Hop.HoppedCellIndex), Color.White);
  }
}</pre>
<p>the &quot;from&quot; and &quot;hopped&quot; cells are restored to their current peg colors, and 
the &quot;to&quot; cell is emptied.</p>
<h4>UpdateUI</h4>
<p>What is this?&nbsp; It's a bit of a kludge of updating the controls and 
injecting a user-controlled delay for each step when the algorithm is running.&nbsp; </p>
<pre>protected void UpdateUI(int fromIdx, int hopIdx, int toIdx, Color fromColor, Color hoppedColor, Color toColor)
{
  WebSocketHelpers.UpdateProperty(&quot;c&quot; + fromIdx, &quot;FillColor&quot;, fromColor.Name);
  WebSocketHelpers.UpdateProperty(&quot;c&quot; + hopIdx, &quot;FillColor&quot;, hoppedColor.Name);
  WebSocketHelpers.UpdateProperty(&quot;c&quot; + toIdx, &quot;FillColor&quot;, toColor.Name);

  // We only call DoEvents and delay when the algorithm is running. If single stepping
  // or perusing the solution, we do NOT want to call DoEvents because additional mouse events
  // could then fire and the state of the game gets messed up.
  if (running)
  {
    lbSolution.DataSource = algorithm.UndoStack.Reverse().ToList();
    tbIterations.Text = algorithm.Iterations.ToString(&quot;#,###,##0&quot;);
    Application.DoEvents();
    System.Threading.Thread.Sleep(tbIterateDelay.Text.to_i());
  }
}</pre>
<p>The code comments are most revealing, as there's a certain entanglement 
between single stepping and running the algorithm.&nbsp; And of course, we have 
to explicitly let the control updates (including the canvas) do their thing.</p>
<h3>Changing the Starting Position</h3>
<p>Changing the starting position updates the game board canvas and the internal 
start position field:</p>
<pre>private void OnStartPositionChanged(object sender, EventArgs e)
{
  startPosition = (int)nudStartPosition.Value;
  ShowPegs();
}</pre>
<p>A real no-brainer!</p>
<h3>Running the Algorithm</h3>
<p>Regardless of which algorithm you choose, running the solver is the same:</p>
<pre>private void btnRun_Click(object sender, EventArgs e)
{
  singleStepping = false;
  ShowPegs();
  algorithm.Initialize(startPosition);
  running = true;
  solutionHops?.Clear();
  lbSolution.DataSource = new List&lt;Hop&gt;();
  algorithm.Run();
  running = false;

  if (algorithm.Solved)
  {
    // From first move to last, because the stack has the last move at the top (index 0) of the stack.
    solutionHops = algorithm.UndoStack.Reverse().ToList();
    RestoreBoard();
    solutionHops.Add(new Hop(-1, 0, 0)); // Fake last entry so we can step to the actual 1 peg remaining.
    lbSolution.DataSource = solutionHops;
    tbIterations.Text = algorithm.Iterations.ToString(&quot;#,###,##0&quot;);
    solutionStep = 0;
    ckShowUi.Checked = true;

    // Reset board so we can navigate the solution
    board.FillAllCells();
    board.RemovePeg(startPosition);
  }
  else
  {
    MessageBox.Show(&quot;No Solution!&quot;, &quot;Brain Teaser&quot;, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
  }
}</pre>
<p>One of the things that took a while to realize was that I needed to unwind 
the solution stack to restore the original board colors (along with the 
earlier-mentioned cloning of the <code>Hop</code> instance):</p>
<pre>/// &lt;summary&gt;
/// Undo all hops to restore board (the cell's peg colors) to their original state.
/// &lt;/summary&gt;
protected void RestoreBoard()
{
  while (algorithm.UndoStack.Count &gt; 0)
  {
    Hop hop = algorithm.UndoStack.Pop();
    board.UndoHopPeg(hop);
    Application.DoEvents();
  }
}</pre>
<p>Sure, I could have just reset the colors from the initial state of the cells, 
but this is a nice proof that undoing all the operations results in the initial 
game board setting.&nbsp; And I worked hard to figure out the issues with this!</p>
<h4>While the Algorthm is Running</h4>
<p>While the algorithm is running, all the controls are disabled except the 
ability to change the delay for each step as it is processed.</p>
<pre>protected void EnableUI(bool state)
{
  // Yes, I'm weird.
  (new Control[] { btnStart, btnSingleStep, nudStartPosition, lbSolution, cbAlgorithm, ckShowUi }).ForEach(ctrl =&gt; ctrl.Enabled = state);
}</pre>
<h3>Single Stepping</h3>
<p>When the user initiates single stepping, this code runs, again regardless of 
the algorithm:</p>
<pre>private void btnSingleStep_Click(object sender, EventArgs e)
{
  // Force UI as otherwise single stepping is sort of pointless.
  ckShowUi.Checked = true;

  if (!singleStepping)
  {
    running = false;
    ShowPegs();
    algorithm.Initialize(startPosition);
    algorithm.StartStepper(); // Used for yield recursion.
  }

  bool next = algorithm.Step();
  tbIterations.Text = algorithm.Iterations.ToString(&quot;#,###,##0&quot;);

  if (next)
  {
    algorithm.PushHop();
    lbSolution.DataSource = algorithm.UndoStack.Reverse().ToList();
  }

  singleStepping = next || (board.RemainingPegs &gt; 1 &amp;&amp; next);
}</pre>
<p>The iteration counter and <code>ListBox</code> updates as the algorithm works on finding a 
solution, giving you a nice visual of the process.&nbsp; This <code>PushHop</code> method is 
sort of an eye-sore for me, as it is only used by the iterating algorithm.&nbsp; 
You'll also notice some other methods, in each algorithm, that don't do anything 
because they are not relevant for the specific algorithm implementation.&nbsp; </p>
<h3>Perusing the Solution</h3>
<p>Lastly, once a solution is found (every starting position has a solution) you 
can click on a step in the <code>ListBox</code> or cursor up/down (once the <code>ListBox</code> is 
selected) and see the solution at your leisure, and memorize a couple to impress 
your friends!</p>
<pre>protected void OnSolutionStepChanged(object sender, EventArgs e)
{
  int newSolStep = lbSolution.SelectedIndex;

  while (newSolStep &gt; solutionStep)
  {
    // Move forward through solution steps.
    board.HopPeg(solutionHops[solutionStep++]);
  }

  while (newSolStep &lt; solutionStep)
  {
    // Move trans-dimensionally through the solution steps.
    board.UndoHopPeg(solutionHops[--solutionStep]);
  }
}</pre>
<h3>Setting the Starting Algorithm</h3>
<p>You'll have to download and build the code to change the algorithm:</p>
<pre>protected void OnShown(object sender, EventArgs e)
{
  board = new Board(NUM_ROWS);
  algorithm = new IterativeAlgorithm(board);
  // algorithm = new RecursiveYieldAlgorithm(board);
  // algorithm = new RecursiveStepAndContinueAlgorithm(board);
  board.DoHop += OnHop;
  board.UndoHop += OnUndoHop;

  WebSocketHelpers.ClearCanvas();
  DrawBoard();
  ShowPegs();
}</pre>
<p><img border="0" src="justKidding.jpg" width="120" height="67"> Just kidding!&nbsp; I overcame my laziness 
(this article has taken way too long, haha):</p>
<p><img border="0" src="ui3.png" width="268" height="154"></p>
<pre>protected void OnSelectedIndexChanged(object sender, EventArgs e)
{
  algorithm = new Algorithm[]
  {
    new IterativeAlgorithm(board),
    new RecursiveYieldAlgorithm(board),
    new RecursiveStepAndContinueAlgorithm(board)
  }[cbAlgorithm.SelectedIndex];
}</pre>
<p>Hmmm.&nbsp; Do you like this better:</p>
<pre>protected void OnSelectedIndexChanged(object sender, EventArgs e)
{
  algorithm = Activator.CreateInstance(new Type[]
  {
    typeof(IterativeAlgorithm),
    typeof(RecursiveYieldAlgorithm),
    typeof(RecursiveStepAndContinueAlgorithm)
  }[cbAlgorithm.SelectedIndex], new object[] { board }) as Algorithm;
}</pre>
<p>Didn't think so.&nbsp; I suppose you were expecting a <code>switch</code> statement?&nbsp; 
From me???</p>
<h2>Conclusion</h2>
<p>As usual, while the code took about 3 hours to write, the article took 3 
times longer!&nbsp; 
Good grief.</p>
<p>On the other hand, I think one of the coolest things about what I've 
presented here are the three different algorithms: iteration, recursive yield, 
and recursive step-and-continue, and as usual, in writing the article, a lot of 
code cleanup occurred!</p>

</body>

</html>